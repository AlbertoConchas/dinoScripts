//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
namespace Assets.My_Assets.dinoScripts.search.bayesiannetwork
{
	public class PearlsMessagePassing
	{

		public List<string> lambdamessages;
		public List<string> pimessages;
		private Dictionary<string, BayesianNode> A;
		private Dictionary<string, Value> a;

		public PearlsMessagePassing()
		{
			A = new Dictionary<string, BayesianNode>();
			a = new Dictionary<string, Value>();
            lambdamessages = new List<string>();
            pimessages = new List<string>();
		}

		public void initial_tree(ref BayesianNode[] nodes, ref BayesianNode root)
		{
			foreach (BayesianNode X in nodes) 
			{
				foreach(KeyValuePair<string, Value> x in X.Values)
				{
					x.Value.Lambdav = 1f;
				}
                BayesianNode Z = X.Parent;
                if (Z != null)
                {
                    foreach (KeyValuePair<string, Value> z in Z.Values)
                    {
                        X.Lambdas[z.Value.Name] = 1f;
                    }
                }
			}
            foreach (KeyValuePair<string, Value> r in root.Values)
            {
                r.Value.Piv = r.Value.Probs[r.Value.Name];
            }
            foreach (KeyValuePair<string, BayesianNode> X in root.Children)
            {
                var ch = X.Value;
                send_pi_message(ref root, ref ch);
            }
            print_messages();
		}

        private void print_messages()
        {
            System.Console.WriteLine("Lambda messages:");
            foreach (string message in lambdamessages)
            {
                System.Console.WriteLine(message);
            }
            System.Console.WriteLine("Pi messages:");
            foreach (string message in pimessages)
            {
                System.Console.WriteLine(message);
            }
        }

		public void update_tree(ref BayesianNode[] nodes, ref BayesianNode root, string Val, string vl)
		{
            //Clean messages
            lambdamessages = new List<string>();
            pimessages = new List<string>();

            //Getting objects
            BayesianNode V = getNode(ref nodes, Val);
            Value v = V.Values[vl];

            //Instantiate V to v_hat
            v.Lambdav = 1f;
            v.Piv = 1f;
            v.Probs[v.Name] = 1f;

            A[V.Name] = V;
            a[v.Name] = v;

            foreach (KeyValuePair<string, Value> val in V.Values)
            {
                if (!val.Value.Equals(v))
                {
                    val.Value.Lambdav = 0f;
                    val.Value.Piv = 0f;
                    val.Value.Probs[v.Name] = 0f;
                }
            }

            //V's parent Z
            BayesianNode Z = V.Parent;
            if (Z != null && !A.ContainsKey(Z.Name))
            {
                send_lambda_message(ref V, ref Z);
            }

            //For each child X of V that X is not in A
            foreach (KeyValuePair<string, BayesianNode> X in V.Children)
            {
                if (!A.ContainsKey(X.Value.Name))
                {
                    var xaux = X.Value;
                    send_pi_message(ref V, ref xaux);
                }
            }

            print_messages();
		}

        public BayesianNode getNode(ref BayesianNode[] nodes, string name)
        {
            foreach (BayesianNode n in nodes)
            {
                if (n.Name.Equals(name))
                {
                    return n;
                }
            }
            return null;
        }

		private void send_lambda_message(ref BayesianNode Y,ref BayesianNode X)
		{
            string msgPis = "Pi: ";
            string msgLambda = "Lambda: ";

            foreach(KeyValuePair<string, Value> x in X.Values)
            {
                //Y sends X a lambda message
                var xaux = x.Value;
                calculate_lambda_message(ref Y, ref xaux);

                msgLambda = msgLambda + " " + x.Value.Name + "=" + Y.Lambdas[x.Value.Name].ToString();
                msgPis = msgPis + " " + x.Value.Name + "=" + Y.Pis[x.Value.Name].ToString();

                //Compute X's lambda values
                var xchaux = X.Children;
                xaux = x.Value;
                x.Value.Lambdav = compute_lambda_value(ref xchaux, ref xaux);

                //Compute P(x|a)
                xaux = x.Value;
                compute_prob_give_a(ref xaux);
            }

            //Normalize P(x|a)
            normalize(ref X);

            lambdamessages.Add(String.Format("Lambda message from {0} to {1}.\nMessage:\n{2}\n{3}", Y.Name, X.Name, msgLambda, msgPis));
            BayesianNode Z = X.Parent;

            if (Z != null && !A.ContainsKey(Z.Name))
            {
                send_lambda_message(ref X, ref Z);
            }

            foreach (KeyValuePair<string, BayesianNode> W in X.Children)
            {
                if (!W.Value.Equals(Y) && !A.ContainsKey(W.Value.Name))
                {
                    var waux = W.Value;
                    send_pi_message(ref X, ref waux);
                }
            }
		}

		private void send_pi_message(ref BayesianNode Z, ref BayesianNode X)
		{
			string msgPis = "Pi: ";
			string msgLambda = "Lambda: ";

			//Z sends X a pi message
			foreach(KeyValuePair<string, Value> z in Z.Values)
			{
				var zaux = z.Value;//Workaround for properties with "pass by reference"
				X.Pis[z.Value.Name] = calculate_pi_message(ref X,ref Z,ref zaux);
				msgLambda = msgLambda + " " + z.Value.Name + "=" + X.Lambdas[z.Value.Name].ToString();
				msgPis = msgPis + " " + z.Value.Name + "=" + X.Pis[z.Value.Name].ToString();
			}

            foreach (KeyValuePair<string, Value> x in X.Values)
            {
                // Compute X's pi values
                var xaux = x.Value;//Workaround for properties with "pass by reference"
                x.Value.Piv = compute_pi_value(ref Z, ref X, ref xaux);

                // Compute P(x|a)
                compute_prob_give_a(ref xaux);
            }

            //Normalize P(x|a)
            normalize(ref X);

            pimessages.Add(String.Format("Pi message from {0} to {1}.\nMessage:\n{2}\n{3}", Z.Name, X.Name, msgLambda, msgPis));

            foreach (KeyValuePair<string, BayesianNode> Y in X.Children)
            {
                if (!A.ContainsKey(Y.Value.Name))
                {
                    var auxY = Y.Value;
                    send_pi_message(ref X, ref auxY);
                }
            }
		}

		private float calculate_pi_message(ref BayesianNode X, ref BayesianNode Z, ref Value z)
		{
            List<float> values = new List<float>();
            float value = 1f;
            foreach (KeyValuePair<string, BayesianNode> Y in Z.Children)
            {
                if (Y.Value != X)
                {
                    try
                    {
                        values.Add(Y.Value.Lambdas[z.Name]);
                    }
                    catch (KeyNotFoundException){}
                }
            }

            if (values.Count > 0)
            {
                foreach(float v in values)
                {
                    value = value * v;
                }
            }

			return z.Piv * value;
		}

		private void calculate_lambda_message(ref BayesianNode Y, ref Value x)
		{
            Dictionary<string, float> lambdas = Y.Lambdas;
            float value = 0f;

            foreach(KeyValuePair<string, Value> y in Y.Values)
            {
                value += (y.Value.Probs[x.Name] * y.Value.Lambdav);
            }
            lambdas[x.Name] = value;
            Y.Lambdas = lambdas;
		}

		private float compute_lambda_value(ref Dictionary<string, BayesianNode> children,ref Value x)
		{
            List<float> values = new List<float>();

            if (children != null && children.Count > 0)
            {
                foreach (KeyValuePair<string, BayesianNode> child in children)
                {
                    try
                    {
                        values.Add(child.Value.Lambdas[x.Name]);
                    }
                    catch (ArgumentException) { }
                }
            }

            float value = 1f;

            foreach (float v in values)
            {
                value = value * v;
            }

			return value;
		}

		private float compute_pi_value(ref BayesianNode Z, ref BayesianNode X, ref Value x)
		{
            float value = 0f;
            
            foreach (KeyValuePair<string, Value> z in Z.Values)
            {
                try
                {
                    value += (x.Probs[z.Value.Name] * X.Pis[z.Value.Name]);
                }catch(KeyNotFoundException){}
            }

            return value;
			
		}

		private void compute_prob_give_a(ref Value x)
		{
            foreach(KeyValuePair<string, Value> aval in a)
            {
                x.Probs[aval.Key] = x.Lambdav * x.Piv;
            }
		}

		private void normalize(ref BayesianNode X)
		{
            float divisor = 0f;

            foreach (KeyValuePair<string, Value> aval in a)
            {
                foreach (KeyValuePair<string, Value> x in X.Values)
                {
                    divisor += x.Value.Probs[aval.Key];
                }
                if (divisor != 0f)
                {
                    foreach (KeyValuePair<string, Value> x in X.Values)
                    {
                        x.Value.Probs[aval.Key] = (x.Value.Probs[aval.Key] / divisor);
                    }
                }
            }
		} 
	}

}